\Ac{GenAI} is rapidly changing the software industry and how software is developed and maintained. The emergence of \acp{LLM}, a subfield of \ac{GenAI}, has opened up new opportunities for enhancing and automating various domains of the \ac{SDLC}. Due to their remarkable capabilities in understanding and generating code, \acp{LLM} have become valuable tools for developers. Everyday tasks such as code generation, refactoring and debugging can be enhanced by using \acp{LLM} \cite{houLargeLanguageModels2024, puvvadiCodingAgentsComprehensive2025}.

Despite these advances, fixing bugs remains a challenging and resource-intensive task, often negatively perceived by developers \cite{winterHowDevelopersReally2023}. It can cause frequent interruptions and context switching, resulting in reduced developer productivity \cite{vasilescuSkyNotLimit2016}. Fixing these bugs can be time-consuming, leading to delays in software delivery and increased costs. %\cite{}
Software bugs harm software quality by causing crashes, vulnerabilities, or even data loss \cite{tihanyiNewEraSoftware2024}. In fact, according to the Consortium for IT Software Quality (CISQ), poor software quality cost the U.S. economy over \$2.4 trillion in 2022, with \$607 billion spent on finding and repairing bugs \cite{CostPoorSoftware}.

Given the critical role of debugging and bug fixing in software development, \ac{APR} has gained significant interest in research and industry. The goal of \ac{APR} is to automate the complex process of bug fixing \cite{houLargeLanguageModels2024}, which typically involves localization, repair, and validation \cite{zhangEmpiricalStudyFactors2012, leeUnifiedDebuggingApproach2024, xiaAgentlessDemystifyingLLMbased2024, zhangPATCHEmpoweringLarge2025, wangEmpiricalResearchUtilizing2025}. Recent research has shown that \acp{LLM} can effectively enhance automated bug fixing, thereby introducing new standards in the APR world and showing potential for significant improvements in the efficiency of the software development process \cite{xiaAgentlessDemystifyingLLMbased2024, liuMarsCodeAgentAInative2024, yangSWEagentAgentComputerInterfaces2024, sobaniaAnalysisAutomaticBug2023, xiaAutomatedProgramRepair2024, huCanGPTO1Kill2024}.

However, existing APR approaches are often complex and require significant computational resources \cite{rondonEvaluatingAgentbasedProgram2025}, making them less applicable in budget-constrained environments or for individual developers. Additionally, the lack of integration with existing software development tooling and lifecycles limits their practical applicability in real-world development environments \cite{chenUnveilingPitfallsUnderstanding2025, liuMarsCodeAgentAInative2024}.

Motivated by these challenges, this thesis explores the potential of integrating LLM-based automated bug fixing into existing software development workflows using \ac{CI} pipelines. \ac{CI} is the backbone of modern software development, ensuring rapid and reliable software releases \cite{ugwuezeContinuousIntegrationDeployment2024}. By leveraging the capabilities of \acp{LLM}, we aim to develop a lightweight and cost-effective prototype for automated bug fixing that seamlessly integrates with \ac{CI} pipelines. Considering computational demands, the complexity of integration, and practical constraints, we aim to provide insights into the possibilities and limitations of our approach by answering the following research questions:

\vspace{1em}

\begin{itemize}
    \item \textbf{RQ1:} How can LLM-based automated bug fixing be effectively and efficiently integrated into a CI pipeline?
    \item \textbf{RQ2:} What are the potentials and limitations of this integrated approach in terms of repair success rate, cost-effectiveness and performance?
\end{itemize}

The thesis is organized as follows:

Chapter \ref{chapter:introduction} provides theoretical background on software development, \ac{GenAI} in the context of software development, and \ac{APR}. Chapter \ref{chapter:method} outlines the methodology used for this thesis, consisting of preparation, implementation, and evaluation. Chapter \ref{chapter:requirements} showcases the functional and non-functional requirements constructed for the prototype.
Chapter \ref{chapter:implementation} explains the implementation and resulting system in detail. Chapter \ref{chapter:results} showcases the resulting workflow when using the prototype and presents the results of the evaluation. Chapter \ref{chapter:discussion} discusses the potentials and limitations of the prototype based on the results. Finally, chapter \ref{chapter:conclusion} concludes the thesis by summarizing the findings and contributions of this work.
