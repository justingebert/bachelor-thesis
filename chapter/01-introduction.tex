Generative AI is rapidly changing the software industry and how software is developed and maintained. The emergence of Large Language Models (LLMs), a subfield of Generative AI, has opened up new opportunities for enhancing and automating various domains of the software development lifecycle. Due to their remarkable capabilities in understanding and generating code, LLMs have become valuable tools for developers. Everyday tasks such as requirements engineering, code generation, refactoring, and debugging can be enhanced by using LLMs \cite{houLargeLanguageModels2024, puvvadiCodingAgentsComprehensive2025}.

Despite these advances, fixing bugs remains a challenging and resource-intensive task, often negatively perceived by developers \cite{winterHowDevelopersReally2023}. It can cause frequent interruptions and context switching, resulting in reduced developer productivity \cite{vasilescuSkyNotLimit2016}. Fixing these bugs can be time-consuming, leading to delays in software delivery and increased costs. %\cite{}
Software bugs can harm software quality by causing crashes, vulnerabilities, or even data loss \cite{tihanyiNewEraSoftware2024}. In fact, according to CISQ, poor software quality cost the U.S. economy over \$2.4 trillion in 2022, with \$607 billion spent on finding and repairing bugs \cite{CostPoorSoftware}.

Given the critical role of debugging and bug fixing in software development, Automated Program Repair (APR) has gained significant research interest. The goal of APR is to automate the complex process of bug fixing \cite{houLargeLanguageModels2024}, which typically involves localization, repair, and validation \cite{zhangEmpiricalStudyFactors2012, leeUnifiedDebuggingApproach2024, xiaAgentlessDemystifyingLLMbased2024, zhangPATCHEmpoweringLarge2025, wangEmpiricalResearchUtilizing2025}. Recent research has shown that LLMs can effectively enhance automated bug fixing, thereby introducing new standards in the APR world and showing potential for significant improvements in the efficiency of the software development process \cite{xiaAgentlessDemystifyingLLMbased2024, liuMarsCodeAgentAInative2024, yangSWEagentAgentComputerInterfaces2024, sobaniaAnalysisAutomaticBug2023, xiaAutomatedProgramRepair2024, huCanGPTO1Kill2024}.

However, existing APR approaches are often complex and require significant computational resources \cite{rondonEvaluatingAgentbasedProgram2025}, making them less applicable in budget-constrained environments or for individual developers. Additionally, the lack of integration with existing software development tooling and lifecycles limits their practical applicability in real-world development environments \cite{chenUnveilingPitfallsUnderstanding2025, liuMarsCodeAgentAInative2024}.

Motivated by these challenges, this thesis explores the potential of integrating LLM-based automated bug fixing into existing software development workflows using Continuous Integration (CI) pipelines. Continuous Integration is the backbone of modern software development, ensuring rapid and reliable software releases \cite{ugwuezeContinuousIntegrationDeployment2024}. By leveraging the capabilities of LLMs, we aim to develop a cost-effective prototype for automated bug fixing that seamlessly integrates with Continuous Integration (CI) pipelines. Considering computational demands, the complexity of integration, and practical constraints, we aim to provide insights into the possibilities and limitations of our approach by answering the following research questions:

\vspace{1em}

\begin{itemize}
    \item \textbf{RQ1:} How can LLM-based automated bug fixing be effectively and efficiently integrated into a CI pipeline?
    \item \textbf{RQ2:} What are the potentials and limitations of this integrated approach in terms of repair success rate, cost-effectiveness and performance?
\end{itemize}

The thesis is organized as follows:

Section 2 provides theoretical background on Software Development, Generative AI in the context of software development, and Automated Program Repair.\\
Section 3 outlines the methodology used for this thesis, consisting of preparation, implementation, and evaluation.\\
Section 4 showcases the functional and non-functional requirements constructed for the prototype.\\
Section 5 explains the implementation and resulting system in detail.\\
Section 6 showcases the resulting workflow when using the prototype and lists the results of the evaluation.\\
Section 7 discusses the potentials and limitations of the prototype based on the results.\\
Finally, section 8 concludes the thesis by summarizing the findings and contributions of this work.
