In this section we break down the implementation of the system into its core components, following the methodology and requirements outlined in the previous chapters. The complete implementation and source code be found in the appendix \ref{chapter:appendix}.

The resulting prototype consists of two main components. The \textbf{APR Core} which holds the core logic for the repair process and a \textbf{CI pipeline} which integrates the APR core logic within a GitHub repository. The \ac{CI} pipeline serves as an entry point and orchestrates the execution of the APR Core based on configured trigger events in the repository.

\section{System Components} \label{section:sc}
The implementation of the main components will be described in detail in the following section.

\textbf{APR Core:}

The APR Core contains the main bug fixing logic written in Python. Embedding it into a Docker Image\footnote{A Docker image is a standardized package that contains all code, libraries and configuration required to run a containerized application \cite{WhatImage0800}.} makes it easy to deploy and portable. In order to use the APR Core the following data (displayed in Table \ref{tab:container-inputs}) needs to passed to the container:

\renewcommand{\arraystretch}{1.5} % Set row spacing to 1.5
\begin{longtable}{@{\extracolsep{\fill}} p{4cm} | p{6cm} | p{4cm}  @{}}
    \caption{APR Core container inputs} \label{tab:container-inputs}                            \\

    \hline
    \textbf{Name}      & \textbf{Description}                            & \textbf{Type}        \\
    \hline
    \endfirsthead

    \hline
    \endfoot
    Source Code        & Git repository where to repair bugs in          & Volume mount
    \\ \hline
    GITHUB\_TOKEN      & Token for GitHub API authentication             & Environment variable \\
    \hline
    LLM\_API\_KEY      & API key for the \ac{LLM} provider               & Environment variable \\
    \hline
    ISSUE\_TO\_PROCESS & The issue to process in JSON format             & Environment variable \\
    \hline
    GITHUB\_REPOSITORY & GitHub repository for fetching and writing data & Environment variable \\
\end{longtable}

With this environment set, the APR Core iterates over all issues fetched from the ``ISSUE\_TO\_PROCESS'' environment variable. For each issue, the main APR logic is executed. This logic follows a predefined flow that makes use of multiple stages and tools.

First, a clean workspace and the issue repair context is set up. The context acts as the central data structure for the issue repair process and is used at every step. Listing \ref{lst:context-json} shows what the context looks like when initialized.

\begin{lstlisting}[style=json, caption={Context JSON}, label={lst:context-json}]  
context = {
    "bug": issue,
    "config": config,
    "state": {
        "current_stage": None,
        "current_attempt": 0,
        "branch": None,
        "repair_successful": False,
    },
    "files": {
        "source_files": [],
        "fixed_files": [],
        "diff_file": None,
        "log_dir": str(log_dir),
    },
    "stages": {},
    "attempts": [],
    "metrics": {
        "github_run_id": os.getenv("GITHUB_RUN_ID"),
        "script_execution_time": 0.0,
        "execution_repair_stages" : {},
        "tokens": {}
    },
}
\end{lstlisting}

This context object is passed between stages, with each stage performing a specific task in the bug fixing process and returning an updated context. The APR core uses four implemented stages: Localize, Fix, Build, and Test.

The repair process for an issue starts with the localization stage. This stage attempts to identify the files in the codebase required to fix the bug, using the configured \ac{LLM} via the provider's Software Development Kit (SDK). A localization prompt is built using the issue and a constructed hierarchy of the repository's file structure. The response is expected to return a list of files where the bug might be located. System instruction and prompt for localization are shown below in Listing \ref{lst:localization-prompt}.

\vspace{3.9cm}

\begin{lstlisting}[style=python, caption={Localization Prompt}, label={lst:localization-prompt}]
system_instruction = "You are a bug localization system. Look at the issue description and return ONLY the exact file paths that need to be modified."

prompt = f"""
    Given the following GitHub issue and repository structure, identify the file(s) that need to be modified to fix the issue.

    Issue #{issue['number']}: {issue['title']}
    Description: {issue.get('body', 'No description provided')}

    Repository files:
    {json.dumps(repo_files, indent=2)}

    Return a JSON array containing ONLY the paths of files that need to be modified to fix this issue.
    Example: ["path/to/file1.py", "path/to/file2.py"]
    """
\end{lstlisting}

With localized files in the context, the Fix stage comes next. This stage calls the configured \ac{LLM} \ac{API} to generate a fix for the issue in the localized files. To construct the prompt, issue details and relevant file names, along with their content, are included. Responses should specify the necessary edits for each file, or indicate when no changes are required. After parsing the generated output, edits are applied to the corresponding files in the workspace. The context is then updated to reflect the new file content. Listing \ref{lst:repair-prompt} shows the system instruction and base prompt used for the Fix stage.

\begin{lstlisting}[style=python, caption={Repair Prompt}, label={lst:repair-prompt}]
system_instruction = "You are part of an automated bug-fixing system. Please return the complete, corrected raw source files for each file that needs changes, never use any markdown formatting. Follow the exact format requested."

base_prompt = f"""
    The following Python code files have a bug. Please fix the bug across all files as needed.

    {files_text}

    Please provide the complete, corrected source files. If a file doesn't need changes, you can indicate that.
    For each file that needs changes, provide the complete corrected file content.
    Format your response as:

    === File: [filepath] ===
    [complete file content or "NO CHANGES NEEDED"]

    === File: [filepath] ===
    [complete file content or "NO CHANGES NEEDED"]
    """
    
\end{lstlisting}

For validating generated fixes, two stages are used: Build and Test. The Build stage is responsible for checking if the code can be built by validating the syntax  the changes made in the Fix stage.  For Python code, this means checking if all syntax is valid and follows standardized code quality and maintenance rules. To achieve this, the code is first formatted using the Python formatter Black\footnote{Black is a code formatter for Python that reformats code to comply with its style guide, aiming for consistent and readable code \cite{Black2510Documentation}.} and then linted using flake8\footnote{Flake8 tool that checks Python source code for compliance with coding standards and potential errors \cite{Flake8YourTool}.}. This ensures properly formatted code and appends any warnings or errors to the context.

If a test command is configured, the next stage of the validation process tests the generated changes. The Test stage runs the tests defined in the repository using the configured test command for each fixed file. In case tests fail, the context is updated with the error messages, and the repair returns to the Fix stage for a new attempt.

For a new attempt, additional feedback is generated using the previous code and stage results. This feedback gets attached to the prompt. When reaching the maximum number of attempts without passing tests, an unsuccessful repair is reported by creating a comment on the issue using the GitHub API.

If both validation stages return a success, the issue is marked as successfully repaired. The file changes are committed and pushed to the remote repository on GitHub. A pull request is then created to merge the issue branch into the main branch. This pull request includes detailed file diffs and links the associated issue.

At this point, integration with the GitHub repository is completed. During execution, every action of the APR Core is logged, logs can be used for debugging and result in a more transparent repair process. Furthermore, it collects metrics such as the number of attempts, execution times, and token usage, which are essential for analyzing the effectiveness and performance of the APR approach. A summary of the metrics collected is mentioned in Section \ref{section:evaluation}.

The APR core is designed to be modular and extensible, allowing for future enhancements and additional stages or tools to be integrated as needed. It is also designed to be lightweight, ensuring that it can run efficiently within a CI environment. Figure \ref{fig:apr-core} illustrates the previously explained functionalities (blue) and tools (green) used in the APR Core.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{images/flowcharts/apr_core.png}
    \caption{APR Core, Source: own representation}
    \label{fig:apr-core}
\end{figure}

\textbf{\ac{CI} Pipeline:}

The APR Core is integrated into GitHub using a GitHub Action workflow to create a \ac{CI} pipeline. This workflow is written in YAML according to the GitHub Action standard \cite{WorkflowSyntaxGitHub}. The pipeline is executed, on a Linux x64 runner provided and hosted by GitHub. This eliminates the overhead of managing our own runners but comes at the cost of uncertain performance and availability.

The workflow is made up of four triggers and three jobs. Triggers are based on events\footnote{Events are specific activities or changes in a repository. \cite{GitHubEventTypes}} from the GitHub repository and serve as the entry point for executing the jobs. Given the triggers, the workflow can be executed in two different ways:

\begin{itemize}
    \item Batch processing by fetching all issues marked for repair. This can be triggered by a manual dispatch (``workflow\_dispatch'') or scheduled execution (``cron'').
    \item Processing a single issue from an event. The issue is passed from the (``issue\_labeled'') event when labeled with the configured label and from (``issue\_comment'') when information is added to the issue in the form of a comment.
\end{itemize}

The trigger event information gets passed as environment variables to the first job named ``gate''. This job uses the event data to determine whether the issue should be processed or skipped. This is determined by a Python script (``filter\_issues.py''). This script must be placed accessible to the workflow file. It checks the labels of issues and evaluates their state to determine which are relevant for the APR process.

If no issues pass the ``gate'', the job ``skipped'' is executed, which logs that no issues were found and exits the workflow run.\\
If at least one issue passes the ``gate'', the ``bugfix'' job is started. This job is responsible for executing the APR Core logic. It sets up the necessary prerequisites (see Table \ref{tab:container-inputs}) to start a container using the latest version of the APR Core Docker Image, which performs the repair. These include checking out and mounting the code repository, setting environment variables, and providing the necessary permissions for the APR Core to edit repository content, create pull requests, and write to issues on GitHub.

The final step of ``bugfix'' uploads all logs and metric files from the APR Core as artifacts to GitHub, making them available after the workflow run has completed.

Figure \ref{fig:ci} visualizes an overview of the workflow and its functionality.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{images/flowcharts/ci.png}
    \caption{CI Pipeline, Source: screenshot}
    \label{fig:ci}
\end{figure}

To use this integration in a repository, the workflow file must be placed in the ``.github/workflows'' directory of the repository along with ``filter\_issues.py'' in ``.github/scripts''. With this in place, an ``LLM\_API\_KEY'' must be set as a secret in the repository settings. This key is used by the APR Core to authenticate with the configured \ac{LLM} provider API. Lastly, GitHub Actions must be granted permissions to create pull requests and write to issues in the repository. This is done by setting the workflow permissions in the repository settings under Actions > General > Workflow permissions. Detailed setup instructions can be found in the repository listed in the Appendix \ref{chapter:appendix}

\section{System Configuration}
%TODO add  collision avoidance
To make the system easily adjustable, the APR Core and the \ac{CI} pipeline can be configured using a YAML configuration file. This configuration is optional, when no configuration is provided, the system falls back to a default setup. A custom configuration must be named ``bugfix.yml'' and placed at the root of the repository. A placed configuration is read by system components during execution. This setup allows for easy customization of the systems behavior without modifying the underlying code. Table \ref{table:configuration} lists the available configuration fields along with their descriptions.

\renewcommand{\arraystretch}{1.5}
\begin{longtable}{@{\extracolsep{\fill}} p{3.5cm} | p{11cm} @{}}
    \caption{Configuration Fields and Descriptions} \label{table:configuration}             \\
    \toprule
    \textbf{Configuration Field} & \textbf{Description}                                     \\
    \midrule
    \endfirsthead

    \bottomrule
    \endfoot

    to\_fix\_label               & The label used to identify issues that need fixing.      \\ \hline
    submitted\_fix\_label        & The label applied to issues when a fix is submitted.     \\ \hline
    failed\_fix\_label           & The label applied to issues when a fix failed.           \\ \hline
    workdir                      & The working directory where the code lives.              \\ \hline
    test\_cmd                    & The command used to run tests on the codebase.           \\ \hline
    branch\_prefix               & The prefix for branches created for bug fixes.           \\ \hline
    main\_branch                 & The main branch where bug fix branches are based.        \\ \hline
    max\_issues                  & The maximum number of issues to process in a single run. \\ \hline
    max\_attempts                & The maximum number of attempts to fix an issue.          \\ \hline
    provider                     & The \ac{LLM} provider used for generating fixes.         \\ \hline
    model                        & The specific model from the \ac{LLM} provider.           \\
\end{longtable}


\section{Requirement Validation}

This section demonstrates how the prototype satisfies the functional and non-functional requirements defined in Chapter \ref{chapter:requirements}. Table \ref{tab:req-validation} summarizes the satisfaction and verification of the requirements with provided screenshots, context excerpts and log excerpts captured during development. Entire logs, configuration files, and context JSON files are available in the GitHub repositories listed in Appendix \ref{chapter:appendix}.

\renewcommand{\arraystretch}{1.5}
\begin{longtable}{@{\extracolsep{\fill}} p{0.5cm} | p{3.5cm} | p{1.5cm} | p{6cm} @{}}
    \caption{Requirement Satisfaction and Validation} \label{tab:req-validation}                                                                                                                                                                      \\
    \hline
    \textbf{ID} & \textbf{Title}                      & \textbf{Satisfied} & \textbf{Verification / Reference}                                                                                                                                        \\
    \hline
    \endfirsthead

    \hline
    \endfoot

    F0          & Multiple Triggers                   & Yes                & See Figure~\ref{fig:triggers}                                                                                                                                            \\ \hline
    F1          & Issue Filtering                     & Yes                & See filtered issues log in Listing~\ref{lst:filtered-issues}                                                                                                             \\ \hline
    F2          & Code Checkout                       & Yes                & See log excerpt in Listing~\ref{fig:code-checkout}                                                                                                                       \\ \hline
    F3          & Bug Localization                    & Yes                & See log excerpt in Listing~\ref{lst:loc}                                                                                                                                 \\ \hline
    F4          & Fix Generation                      & Yes                & See context excerpt in Listing~\ref{fig:fix}                                                                                                                             \\ \hline
    F5          & Change Validation                   & Yes                & See log excerpt in Listing~\ref{fig:validation}                                                                                                                          \\ \hline
    F6          & Iterative Patch \newline Generation & Yes                & See log excerpt in Listing~\ref{fig:retry}                                                                                                                               \\ \hline
    F7          & Patch Application                   & Yes                & See log excerpt in Listing~\ref{lst:branch-commit}                                                                                                                        \\ \hline
    F8          & Result Reporting                    & Yes                & See Figure~\ref{fig:pr-report} and Figure \ref{fig:comment}                                                                                                              \\ \hline
    F9          & Log and Metric \newline  Collection & Yes                & See Figure~\ref{fig:logs-artifacts}                                                                                                                                      \\ \hline
    N0          & Container Runtime                   & Yes                & See log excerpt in Listing~\ref{lst:docker-log}                                                                                                                          \\ \hline
    N1          & Configurable                        & Yes                & See log excerpts from Listing \ref{lst:load-config}                                                                                                                     \\ \hline
    N2          & Portable                            & Yes                & Used in two repositories: see Appendix~\ref{chapter:appendix}                                                                                                            \\ \hline
    N3          & Run Repeatable                      & No                 & Due to non deterministic LLM outputs and varying execution environments, identical runs resulted in different results. See discussion in Section~\ref{section:validity}. \\ \hline
    N4          & Observable                          & Yes                & See Figure~\ref{fig:logs-artifacts}{fig:metrics}.                                                                                                                       \\ \hline
    N5          & End-to-End Automation               & Yes                & See full process in Section \ref{section:showcase}                                                                                                                      \\ \hline
\end{longtable}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{images/verification/triggers.png}
    \caption{Workflow triggers for APR system, Source: screenshot}
    \label{fig:triggers}
\end{figure}

\vspace{0.5cm}

\begin{lstlisting}[style=log, caption={Filtered issues log excerpt}, label={lst:filtered-issues}, basicstyle=\ttfamily\small, breaklines=true, frame=single, columns=fullflexible]
Found 1 issues to process
[{"number": 27, "title": "Problem in next_palindrome", "body": "There is a bug in **`next_palindrome`**.", "labels": ["bug_v01", "quixbugs"]}]
\end{lstlisting}

\begin{lstlisting}[style=log, caption={Code checkout log excerpt}, label={fig:code-checkout}, basicstyle=\ttfamily\small, breaklines=true, frame=single, columns=fullflexible]
Run actions/checkout@v4
Syncing repository: justingebert/bugfix-ci
Getting Git version info
Temporarily overriding HOME='/home/runner/work/_temp/6ca8e386-1931-4130-8b38-cd4993a6fa1f' before making global git config changes
Adding repository directory to the temporary git global config as a safe directory
/usr/bin/git config --global --add safe.directory /home/runner/work/bugfix-ci/bugfix-ci
Deleting the contents of '/home/runner/work/bugfix-ci/bugfix-ci'
Initializing the repository
Disabling automatic garbage collection
Setting up auth
Fetching the repository
Determining the checkout info
/usr/bin/git sparse-checkout disable
/usr/bin/git config --local --unset-all extensions.worktreeConfig
Checking out the ref
/usr/bin/git log -1 --format=%H
465a84dc8a989cd1ba7603324687f7d57cdc0998
\end{lstlisting}

\begin{lstlisting}[style=log, caption={Bug localization log excerpt}, label={lst:loc}]
root - INFO - [localize] LLM response: ["next_palindrome.py"]
\end{lstlisting}

\begin{lstlisting}[style=json, caption={Fix generation log excerpt}, label={fig:fix}]
    "fix_attempt_1": {
        "results": {
          "status": "success",
          "message": "Successfully fixed files",
          "details": {
            "fixed_files": [
              "/workspace/quixbugs/python_programs/next_palindrome.py"
            ],
            "tokens": {
              "input_tokens": 431,
              "output_tokens": 288,
              "total_tokens": 719,
              "cost": 0.0006332
            },
            "raw_response": "=== File: /workspace/quixbugs/python_programs/next_palindrome.py ===\ndef next_palindrome(digit_list):\n    high_mid = len(digit_list) // 2\n    low_mid = (len(digit_list) - 1) // 2\n    while high_mid < len(digit_list) and low_mid >= 0:\n        if digit_list[high_mid] == 9:\n            digit_list[high_mid] = 0\n            digit_list[low_mid] = 0\n            high_mid += 1\n            low_mid -= 1\n        else:\n            digit_list[high_mid] += 1\n            if low_mid != high_mid:\n                digit_list[low_mid] = digit_list[high_mid]\n            return digit_list\n    return [1] + (len(digit_list) - 1) * [0] + [1]\n\n\"\"\"\nFinds the next palindromic integer when given the current integer\nIntegers are stored as arrays of base 10 digits from most significant to least significant\n\nInput:\n    digit_list: An array representing the current palindrome\n\nOutput:\n    An array which represents the next palindrome\n\nPreconditions:\n    The initial input array represents a palindrome\n\nExample\n    >>> next_palindrome([1,4,9,4,1])\n    [1,5,0,5,1]\n\"\"\""
          }
        },
        "duration": 7.0682
      },
\end{lstlisting}

\begin{lstlisting}[style=log, caption={Change validation log excerpt}, label={fig:validation}]
    root - INFO - == Running stage: build ==
    root - INFO - [build] starting build process 
    root - INFO - [build] Formatting /workspace/quixbugs/python_programs/next_palindrome.py with black...
    root - INFO - [build] /workspace/quixbugs/python_programs/next_palindrome.py formatted successfully by black.
    root - INFO - [build] Linting /workspace/quixbugs/python_programs/next_palindrome.py with flake8...
    root - WARNING - [build] flake8 found issues in /workspace/quixbugs/python_programs/next_palindrome.py:
    /workspace/quixbugs/python_programs/next_palindrome.py:20:80: E501 line too long (90 > 79 characters)
    
    root - ERROR - [build] Build failed. 1 files with issues.
    root - INFO - == Stage build completed in 0.5411 seconds ==
    root - INFO - == Running stage: test ==
    root - INFO - [test] running tests for fixed files
    root - INFO - [test] Testing next_palindrome...
    root - INFO - [test] Looking for specific test: /workspace/quixbugs/python_testcases/test_next_palindrome.py
    root - INFO - [test] Executing test command: cd /workspace/quixbugs && python -m pytest python_testcases/test_next_palindrome.py -v
    root - INFO - [test] Specific test passed for next_palindrome.
\end{lstlisting}

\begin{lstlisting}[style=log, caption={Iterative patch generation log excerpt}, label={fig:retry}]
    root - INFO - [test] Specific test failed for wrap.
    root - ERROR - [test] Tests failed. 1 files with test failures.
    root - INFO - == Stage test completed in 0.5417 seconds ==
    root - INFO - === Repair failed on attempt 1/3, trying again ===
    root - INFO - Resetting to main branch
    root - INFO - Reset /workspace/python_programs/wrap.py to main branch
    root - INFO - === Attempt 2/3 for issue #47 ===
    root - INFO - == Running stage: fix ==
    root - INFO - Loaded file: /workspace/python_programs/wrap.py
\end{lstlisting}

\begin{lstlisting}[style=log, caption={Branch and commit created for bugfix}, label={lst:branch-commit}]
    root - INFO - === Repair successful on attempt 1/1 ===
    root - INFO - Added file /workspace/quixbugs/python_programs/next_palindrome.py to staging area
    root - INFO - 1 files with changes committed to branch bugfix_v01_27
    root - INFO - Push successful
\end{lstlisting}


\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{images/verification/pr.png}
    \caption{Pull request report for bugfix, Source: screenshot}
    \label{fig:pr-report}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{images/verification/comment.png}
    \caption{Issue comment reporting repair result, Source: screenshot}
    \label{fig:comment}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{images/verification/artifacts.png}
    \caption{Downloadable Artifacts from workflow run, Source: screenshot}
    \label{fig:logs-artifacts}
\end{figure}

\begin{lstlisting}[style=log, caption={Docker container runtime log excerpt}, label={lst:docker-log}]
    Downloaded newer image for ghcr.io/justingebert/bugfix-ci:latest
    Run docker run --rm \
    docker run --rm \
      -v "$GITHUB_WORKSPACE:/workspace" \
      -e GITHUB_TOKEN -e GITHUB_RUN_ID -e GITHUB_REPOSITORY -e LLM_API_KEY -e FILTERED_ISSUES \
      ghcr.io/justingebert/bugfix-ci:latest
    shell: /usr/bin/bash -e {0}
    env:
      GITHUB_TOKEN: ***
      GITHUB_REPOSITORY: justingebert/bugfix-ci
      GITHUB_RUN_ID: 16531173399
      LLM_API_KEY: ***
      FILTERED_ISSUES: [{"number": 27, "title": "Problem in next_palindrome", "body": "There is a bug in **`next_palindrome`**.\n\n* **File**: `/Users/justingebert/Projects/Uni/BA/bugfix-ci/datasets/quixbugs/python_programs/next_palindrome.py`", "labels": ["bug_v01", "quixbugs"]}]
\end{lstlisting}

\begin{lstlisting}[style=log, caption={Load custom configuration}, label={lst:load-config}]
    root - INFO - [info] loaded default config from apr_core/default-config.yml
    root - INFO - [info] loaded config from /workspace/bugfix.yml
\end{lstlisting}